---
import { getFormatter, getMinifier } from "@/handlers";
import Copy from "@/icons/copy.astro";
import Format from "@/icons/format.astro";
import Minify from "@/icons/minify.astro";
import Reset from "@/icons/reset.astro";
import { getInitialCode } from "@/lib/initialCode";
import { scope } from "simple:scope";
import ThemeSelector from "../layout/ThemeSelector.astro";
import Button from "../ui/button.astro";
import MonacoPlayground from "./MonacoPlayground.astro";

interface Props {
  minifier: boolean;
  language: string;
}

const { language, minifier } = Astro.props;

// Get the correct initial code for the current language
const initialCode = getInitialCode(language);
---

<RootElement>
  <div
    class="flex flex-col items-center w-full"
    data-language={language}
    data-target="root"
    id="formatter"
  >
    <div
      class="w-full max-w-[1400px] bg-card border border-border rounded-xl shadow-xs overflow-hidden"
    >
      <!-- Toolbar -->
      <div
        class="flex flex-col sm:flex-row items-center justify-between p-2 sm:p-3 border-b border-border bg-muted/30 gap-4 sm:gap-0"
      >
        <div
          class="flex items-center gap-4 w-full sm:w-auto justify-between sm:justify-start"
        >
          <div class="flex items-center gap-2">
            <div class="flex space-x-1.5 px-2">
              <div class="w-2.5 h-2.5 rounded-full bg-red-500/80"></div>
              <div class="w-2.5 h-2.5 rounded-full bg-yellow-500/80"></div>
              <div class="w-2.5 h-2.5 rounded-full bg-green-500/80"></div>
            </div>
            <span
              class="text-xs font-medium text-muted-foreground ml-2 border-l border-border pl-3 uppercase tracking-wider"
              >Editor</span
            >
          </div>

          <div class="sm:hidden">
            <ThemeSelector class="w-24" />
          </div>
        </div>

        <div class="flex items-center gap-2 w-full sm:w-auto">
          <div class="hidden sm:block mr-2">
            <ThemeSelector class="w-32" />
          </div>

          <div class="h-4 w-px bg-border hidden sm:block mx-1"></div>

          <Button
            size="sm"
            variant="ghost"
            target={scope("format")}
            class="flex-1 sm:flex-none h-7 text-xs font-medium text-muted-foreground hover:text-foreground hover:bg-muted/60 data-[state=active]:bg-muted data-[state=active]:text-foreground"
          >
            <Format class="w-3.5 h-3.5 mr-1.5" /> Format
          </Button>

          {
            minifier && (
              <Button
                size="sm"
                variant="ghost"
                target={scope("minify")}
                class="flex-1 sm:flex-none h-7 text-xs font-medium text-muted-foreground hover:text-foreground hover:bg-muted/60"
              >
                <Minify class="w-3.5 h-3.5 mr-1.5" /> Minify
              </Button>
            )
          }

          <Button
            size="sm"
            variant="ghost"
            target={scope("copy")}
            class="flex-1 sm:flex-none h-7 text-xs font-medium text-muted-foreground hover:text-foreground hover:bg-muted/60"
          >
            <Copy class="w-3.5 h-3.5 mr-1.5" /> Copy
          </Button>

          <div class="h-4 w-px bg-border hidden sm:block mx-1"></div>

          <Button
            size="sm"
            variant="ghost"
            target={scope("reset")}
            class="flex-1 sm:flex-none h-7 text-xs font-medium text-muted-foreground hover:text-red-500 hover:bg-red-500/10"
            title="Reset to default"
          >
            <Reset class="w-3.5 h-3.5 mr-1.5" /> Reset
          </Button>
        </div>
      </div>

      <!-- Editor Area -->
      <div class="relative w-full h-[70vh] min-h-[500px] bg-background group">
        <MonacoPlayground inputCode={initialCode} language={language} />

        <!-- Floating Action Button for Mobile? No, toolbar is enough. -->
      </div>

      <!-- Status Bar -->
      <div
        class="flex items-center justify-between px-4 py-1.5 bg-muted/50 border-t border-border text-[10px] uppercase tracking-wider text-muted-foreground font-medium"
      >
        <div class="flex items-center gap-4">
          <span>{language}</span>
          <span>UTF-8</span>
          <span
            class="hidden sm:inline-flex items-center gap-1.5 text-green-600 dark:text-green-400"
          >
            <svg
              xmlns="http://www.w3.org/2000/svg"
              width="12"
              height="12"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            >
              <path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"></path>
              <path d="m9 12 2 2 4-4"></path>
            </svg>
            Processed Locally
          </span>
        </div>
        <div class="flex gap-4">
          <span class="flex items-center gap-1.5">
            <span class="w-1.5 h-1.5 rounded-full bg-green-500 animate-pulse"
            ></span>
            Ready
          </span>
        </div>
      </div>
    </div>

    <div class="w-full max-w-[1400px] mt-4 flex justify-center">
      <div
        class="inline-flex items-center gap-2 px-3 py-1 rounded-full bg-muted/50 border border-border text-xs text-muted-foreground"
      >
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="14"
          height="14"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          stroke-width="2"
          stroke-linecap="round"
          stroke-linejoin="round"
        >
          <rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect>
          <path d="M7 11V7a5 5 0 0 1 10 0v4"></path>
        </svg>
        Your code is processed entirely in your browser and is never sent to any server.
      </div>
    </div>
  </div>
</RootElement>

<script>
  import { getFormatter, getMinifier } from "@/handlers";
import { getInitialCode } from "@/lib/initialCode";

  RootElement.ready(async ($) => {
    const divElement = $("root");
    const language = divElement.dataset.language!;

    const formatter = await getFormatter(language);
    const minifier = await getMinifier(language);

    async function getCurrentMonacoContent(): Promise<string> {
      const playground = document.getElementById("monaco-playground");

      if (!playground) {
        return getInitialCode(language);
      }

      try {
        const content =
          await window.MonacoPlayground.getCurrentContent(playground);
        return content || getInitialCode(language);
      } catch (error) {
        return getInitialCode(language);
      }
    }

    const trackEvent = (eventName: string, eventLabel: string) => {
      try {
        gtag("event", eventName, {
          event_category: "Button",
          event_label: eventLabel,
          value: language,
        });
      } catch (err) {}
    };

    const showTickAnimation = (button: HTMLButtonElement, text: string) => {
      const originalIcon = button.innerHTML;
      button.innerHTML =
        '<svg class="w-4 h-4 mr-2" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7" /></svg> ' +
        text;
      setTimeout(() => {
        button.innerHTML = originalIcon;
      }, 2000);
    };

    const formatButton = $("format") as HTMLButtonElement;
    formatButton.addEventListener("click", async () => {
      try {
        const inputCode = await getCurrentMonacoContent();

        if (!inputCode || inputCode.trim() === "") {
          // No code to format
          return;
        }

        const formatted = await formatter.formatCode(inputCode);
        showTickAnimation(formatButton, "Formatted");

        try {
          const playground = document.getElementById("monaco-playground");
          if (playground) {
            await window.MonacoPlayground.updateContent(playground, formatted);
          }
        } catch (error) {
          console.error("Failed to update editor with formatted code:", error);
        }
      } catch (error) {
        console.error("Invalid code. Please check your syntax.", error);
      }

      trackEvent(`Format ${language} Click`, "click");
    });

    if (minifier) {
      const minifyButton = $("minify") as HTMLButtonElement;
      minifyButton.addEventListener("click", async () => {
        try {
          const inputCode = await getCurrentMonacoContent();

          if (!inputCode || inputCode.trim() === "") {
            // No code to minify
            return;
          }

          const minified = await minifier.minifyCode(inputCode);
          showTickAnimation(minifyButton, "Minified");

          try {
            const playground = document.getElementById("monaco-playground");
            if (playground) {
              await window.MonacoPlayground.updateContent(playground, minified);
            }
          } catch (error) {
            console.error("Failed to update editor with minified code:", error);
          }
        } catch (error) {
          console.error("Invalid code. Please check your syntax.", error);
        }

        trackEvent(`Minify ${language} Click`, "click");
      });
    }

    const copyButton = $("copy") as HTMLButtonElement;
    copyButton.addEventListener("click", async () => {
      try {
        const contentToCopy = await getCurrentMonacoContent();
        await navigator.clipboard.writeText(contentToCopy);
        showTickAnimation(copyButton, "Copied");
        trackEvent(`Copy ${language} Click`, "click");
      } catch (error) {
        console.error("Failed to copy content to clipboard:", error);
      }
    });

    const resetButton = $("reset") as HTMLButtonElement;
    resetButton.addEventListener("click", async () => {
      try {
        const playground = document.getElementById("monaco-playground");
        if (playground) {
          await window.MonacoPlayground.updateContent(
            playground,
            getInitialCode(language)
          );
          showTickAnimation(resetButton, "Reset");
        }
      } catch (error) {
        console.error("Failed to reset editor content:", error);
      }
      trackEvent(`Reset ${language} Click`, "click");
    });
  });
</script>
