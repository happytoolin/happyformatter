---
interface Props {
  inputCode: string;
  language: string;
}

const { inputCode, language } = Astro.props;
---

<div
  class="transition-none"
  style="color-scheme: inherit"
  data-language={language}
  data-initial-code={inputCode}
  id="monaco-playground"
  data-astro-transition-persist="monaco-playground"
>
  <monaco-editor
    id="monaco-editor"
    style="width: 100%; height: 800px"
    line-numbers="on"
    fontFamily="Geist Mono"
    fontSize="16"
    data-astro-transition-persist="monaco-editor"></monaco-editor>
</div>

<script>
  import { getInitialCode } from "@/lib/initialCode";
import { lazy, Workspace } from "modern-monaco";
  // Get all supported languages and their initial code
  const supportedLanguages = [
    "json",
    "javascript",
    "typescript",
    "html",
    "css",
    "scss",
    "xml",
    "go",
    "java",
    "csharp",
    "c",
    "cpp",
    "python",
    "sql",
    "rust",
    "dart",
    "lua",
    "markdown",
    "yaml",
    "toml",
    "zig",
    "proto",
    "php",
  ];

  const languageExtensions = {
    json: "json",
    javascript: "js",
    typescript: "ts",
    html: "html",
    css: "css",
    scss: "scss",
    xml: "xml",
    go: "go",
    java: "java",
    csharp: "cs",
    c: "c",
    cpp: "cpp",
    python: "py",
    sql: "sql",
    rust: "rs",
    dart: "dart",
    lua: "lua",
    markdown: "md",
    yaml: "yaml",
    toml: "toml",
    zig: "zig",
    proto: "proto",
    php: "php",
  } as const;

  const initialFiles: Record<string, string> = {};
  supportedLanguages.forEach((lang) => {
    const fileName = `example.${
      languageExtensions[lang as keyof typeof languageExtensions]
    }`;
    initialFiles[fileName] = getInitialCode(lang);
  });

  console.log(initialFiles);

  let workspace: Workspace | null = null;
  let isInitialized = false;

  async function switchToLanguageFile(language: string) {
    if (!workspace) return;

    try {
      const fileName = `example.${language}`;
      console.log(`Switching to ${language} file: ${fileName}`);

      // Get the Monaco instance from workspace
      const monaco = await (workspace as any)._monaco.promise;

      if (!monaco) {
        throw new Error("Monaco instance not available");
      }

      // Get the editor instance
      const editors = monaco.editor.getEditors();
      if (editors.length === 0) {
        throw new Error("No Monaco editors found");
      }

      const editor = editors[0];
      const modelUri = monaco.Uri.parse(`file:///${fileName}`);

      // Try to get existing model first
      let model = monaco.editor.getModel(modelUri);

      if (!model) {
        // Read the content from workspace filesystem
        let content: string;
        try {
          content = await workspace.fs.readTextFile(fileName);
        } catch (fileError) {
          console.warn(`File ${fileName} not found in workspace, using initial code`);
          const { getInitialCode } = await import("@/lib/initialCode");
          content = getInitialCode(language);
        }

        // Create model with proper language
        model = monaco.editor.createModel(content, language, modelUri);
        console.log(`Created new model for ${fileName} with language: ${language}`);
      } else {
        // Ensure the existing model has the correct language set
        const currentLanguage = model.getLanguageId();
        if (currentLanguage !== language) {
          // Use Monaco's built-in method to set the language
          monaco.editor.setModelLanguage(model, language);
          console.log(`Updated model language from ${currentLanguage} to ${language}`);
        }
      }

      // Set the model on the editor - this switches the displayed content and language
      editor.setModel(model);

      // Force a refresh of the editor's theme and language services
      editor.updateOptions({});

      console.log(`Successfully switched to ${language} file: ${fileName}`);
      console.log(`Final model language: ${model.getLanguageId()}`);
    } catch (error) {
      console.error(`Failed to switch to ${language} file:`, error);
    }
  }

  async function initializeMonacoEditor() {
    if (isInitialized) return;

    const playground = document.getElementById("monaco-playground");
    const editor = document.getElementById("monaco-editor");
    const language = playground?.dataset.language as string;

    const extension =
      languageExtensions[language as keyof typeof languageExtensions];

    if (!language || !editor) return;

    try {
      workspace = new Workspace({
        // name: `${language}-workspacea`,
        name: "formatter-workspace",
        initialFiles: initialFiles,
        entryFile: `example.${extension}`,
        browserHistory: false,
      });

      // Initialize the editor with all supported languages
      void lazy({
        workspace,
        theme: "vitesse-dark",
        langs: [
          "json",
          "javascript",
          "typescript",
          "html",
          "css",
          "scss",
          "xml",
          "go",
          "java",
          "csharp",
          "c",
          "cpp",
          "python",
          "sql",
          "rust",
          "dart",
          "lua",
          "markdown",
          "yaml",
          "toml",
          "zig",
          "proto",
          "php",
        ],
      });

      isInitialized = true;
      console.log("Monaco workspace initialized with all language files");
    } catch (error) {
      console.error("Failed to initialize Monaco editor:", error);
    }
  }

  // Initialize when DOM is ready
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initializeMonacoEditor);
  } else {
    initializeMonacoEditor();
  }

  // Expose the Monaco playground API globally for the formatter component
  (window as any).MonacoPlayground = {
    async getCurrentContent(_playgroundElement: HTMLElement): Promise<string> {
      if (!workspace) {
        console.error("Workspace not available");
        return "";
      }

      try {
        const monaco = await (workspace as any)._monaco.promise;
        const editors = monaco.editor.getEditors();
        if (editors.length === 0) return "";

        const editor = editors[0];
        const model = editor.getModel();
        return model ? model.getValue() : "";
      } catch (error) {
        console.error("Failed to get current content:", error);
        return "";
      }
    },

    async updateContent(_playgroundElement: HTMLElement, newContent: string): Promise<void> {
      if (!workspace) {
        console.error("Workspace not available");
        return;
      }

      try {
        const monaco = await (workspace as any)._monaco.promise;
        const editors = monaco.editor.getEditors();
        if (editors.length === 0) return;

        const editor = editors[0];
        const model = editor.getModel();
        if (model) {
          model.setValue(newContent);
        }
      } catch (error) {
        console.error("Failed to update content:", error);
      }
    }
  };

  // Listen for Astro's SPA navigation events
  document.addEventListener("astro:before-swap", () => {
    console.log("astro:before-swap detected - preserving Monaco editor state");
    // The editor should remain intact since we're using view transitions
  });

  document.addEventListener("astro:after-swap", async () => {
    const playground = document.getElementById("monaco-playground");
    if (playground && isInitialized) {
      const newLanguage = playground.dataset.language;
      console.log("astro:after-swap detected, new language:", newLanguage);

      // Wait a bit longer to ensure DOM is stable and Monaco is ready
      await new Promise(resolve => setTimeout(resolve, 150));

      try {
        // Check if the Monaco editor is still available
        const monaco = await (workspace as any)._monaco.promise;
        const editors = monaco.editor.getEditors();
        console.log("Available editors after swap:", editors.length);

        if (editors.length === 0) {
          console.warn("No editors found after swap, this might indicate a DOM replacement issue");
          return;
        }

        if (newLanguage) {
          await switchToLanguageFile(newLanguage);
        }
      } catch (error) {
        console.error("Error in after-swap handling:", error);
      }
    }
  });
</script>
