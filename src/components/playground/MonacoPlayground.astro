---
interface Props {
  inputCode: string;
  language: string;
}

const { inputCode, language } = Astro.props;
---

<div
  class="transition-none"
  style="color-scheme: inherit"
  data-language={language}
  data-initial-code={inputCode}
  id="monaco-playground"
  data-astro-transition-persist="monaco-playground"
>
  <!-- Skeleton loading state -->
  <div
    id="skeleton-loader"
    class="animate-pulse bg-muted rounded-lg p-4"
    style="height: 800px;"
  >
    <div class="space-y-3">
      <div class="h-4 bg-gray-700 rounded w-3/4"></div>
      <div class="h-4 bg-gray-700 rounded w-1/2"></div>
      <div class="h-4 bg-gray-700 rounded w-5/6"></div>
      <div class="h-4 bg-gray-700 rounded w-2/3"></div>
      <div class="h-4 bg-gray-700 rounded w-4/5"></div>
      <div class="h-4 bg-gray-700 rounded w-1/3"></div>
      <div class="h-4 bg-gray-700 rounded w-3/4"></div>
      <div class="h-4 bg-gray-700 rounded w-2/5"></div>
    </div>
  </div>

  <monaco-editor
    id="monaco-editor"
    style="width: 100%; height: 800px; visibility: hidden; opacity: 0; transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;"
    line-numbers="on"
    fontFamily="Geist Mono"
    fontSize="16"
    theme="vitesse-dark"
    data-astro-transition-persist="monaco-editor"
  ></monaco-editor>
</div>

<script>
import { getInitialCode } from "@/lib/initialCode";
import { lazy, Workspace } from "modern-monaco";
// Get all supported languages and their initial code
const supportedLanguages = [
  "json",
  "javascript",
  "typescript",
  "html",
  "css",
  "scss",
  "xml",
  "go",
  "java",
  "csharp",
  "c",
  "cpp",
  "python",
  "sql",
  "rust",
  "dart",
  "lua",
  "markdown",
  "yaml",
  "toml",
  "zig",
  "proto",
  "php",
];

const languageExtensions = {
  json: "json",
  javascript: "js",
  typescript: "ts",
  html: "html",
  css: "css",
  scss: "scss",
  xml: "xml",
  go: "go",
  java: "java",
  csharp: "cs",
  c: "c",
  cpp: "cpp",
  python: "py",
  sql: "sql",
  rust: "rs",
  dart: "dart",
  lua: "lua",
  markdown: "md",
  yaml: "yaml",
  toml: "toml",
  zig: "zig",
  proto: "proto",
  php: "php",
} as const;

const initialFiles: Record<string, string> = {};

// Add a minimal skeleton placeholder as the default entry
const skeletonContent = `//`;

initialFiles["welcome.txt"] = skeletonContent;

// Add all language files
supportedLanguages.forEach((lang) => {
  const fileName = `example.${
    languageExtensions[lang as keyof typeof languageExtensions]
  }`;
  initialFiles[fileName] = getInitialCode(lang);
});

console.log("Initial files created with welcome.txt as entry point");

let workspace: Workspace | null = null;
let isInitialized = false;
let isTransitioning = false;

function showEditor() {
  const monacoEditor = document.getElementById("monaco-editor");
  const skeletonLoader = document.getElementById("skeleton-loader");

  if (monacoEditor && skeletonLoader) {
    // Fade out skeleton
    skeletonLoader.style.opacity = "0";
    skeletonLoader.style.visibility = "hidden";

    // Fade in editor
    monacoEditor.style.opacity = "1";
    monacoEditor.style.visibility = "visible";
  }
}

function hideEditor() {
  const monacoEditor = document.getElementById("monaco-editor");
  const skeletonLoader = document.getElementById("skeleton-loader");

  if (monacoEditor && skeletonLoader) {
    // Fade out editor
    monacoEditor.style.opacity = "0";
    monacoEditor.style.visibility = "hidden";

    // Fade in skeleton
    skeletonLoader.style.opacity = "1";
    skeletonLoader.style.visibility = "visible";
  }
}

async function switchToLanguageFile(language: string) {
  if (!workspace || isTransitioning) {
    console.error("Workspace not available or already transitioning");
    return;
  }

  isTransitioning = true;

  try {
    const fileName = `example.${language}`;
    console.log(`=== SWITCHING TO ${language} file: ${fileName} ===`);

    // Get the Monaco instance from workspace
    const monaco = await (workspace as any)._monaco.promise;

    if (!monaco) {
      throw new Error("Monaco instance not available");
    }

    // Get the editor instance
    const editors = monaco.editor.getEditors();
    if (editors.length === 0) {
      throw new Error("No Monaco editors found");
    }

    const editor = editors[0];
    console.log(
      "Editor found, current model:",
      editor.getModel()?.getLanguageId(),
    );

    const modelUri = monaco.Uri.parse(`file:///${fileName}`);

    // Check if model already exists and reuse it
    let model = monaco.editor.getModel(modelUri);

    if (!model) {
      // Create new model only if it doesn't exist
      let content: string;
      try {
        content = await workspace.fs.readTextFile(fileName);
        console.log(
          `Read ${content.length} chars from workspace file: ${fileName}`,
        );
      } catch (fileError) {
        console.warn(
          `File ${fileName} not found in workspace, using initial code`,
        );
        const { getInitialCode } = await import("@/lib/initialCode");
        content = getInitialCode(language);
        console.log(
          `Using initial code for ${language}: ${content.length} chars`,
        );
      }

      model = monaco.editor.createModel(content, language, modelUri);
      console.log(`Created new model for ${fileName} with language: ${language}`);
    } else {
      console.log(`Reusing existing model for ${fileName}`);
    }

    // Set the model on the editor - this switches the displayed content and language
    editor.setModel(model);

    // Minimal theme and layout refresh
    try {
      editor.layout();
    } catch (themeError) {
      console.warn("Failed to refresh editor:", themeError);
    }

    // Smooth transition: show editor immediately since content is ready
    showEditor();

    // Verify the switch
    const finalModel = editor.getModel();
    const finalLanguage = finalModel ? finalModel.getLanguageId() : "none";
    const finalContent = finalModel
      ? finalModel.getValue().substring(0, 50) + "..."
      : "empty";

    console.log(`=== SWITCH COMPLETED ===`);
    console.log(`Target: ${language}`);
    console.log(`Actual language: ${finalLanguage}`);
    console.log(`Content preview: ${finalContent}`);
    console.log(`Model matches target: ${finalLanguage === language}`);
  } catch (error) {
    console.error(`Failed to switch to ${language} file:`, error);
    // Show editor even on error to avoid broken state
    showEditor();
  } finally {
    isTransitioning = false;
  }
}

async function initializeMonacoEditor() {
  if (isInitialized) return;

  const playground = document.getElementById("monaco-playground");
  const editor = document.getElementById("monaco-editor");

  // Get language from URL to be more reliable
  const path = window.location.pathname;
  const pathMatch = path.match(/\/([^.]+)(?:\.astro)?$/);
  const language = pathMatch
    ? pathMatch[1]
    : playground?.dataset.language as string;

  if (!language || !editor) return;

  console.log(
    `Initializing Monaco for language: ${language} (from URL: ${path})`,
  );

  try {
    workspace = new Workspace({
      name: "formatter-workspace",
      initialFiles: initialFiles, // Use the original order with welcome.txt first
      entryFile: "welcome.txt", // Always start with welcome file
      browserHistory: false,
    });

    // Initialize the editor with all supported languages and theme
    await lazy({
      workspace,
      theme: "vitesse-dark",
      langs: [
        "json",
        "javascript",
        "typescript",
        "html",
        "css",
        "scss",
        "xml",
        "go",
        "java",
        "csharp",
        "c",
        "cpp",
        "python",
        "sql",
        "rust",
        "dart",
        "lua",
        "markdown",
        "yaml",
        "toml",
        "zig",
        "proto",
        "php",
      ],
    });

    // Single theme setting after everything is loaded
    try {
      const monaco = await (workspace as any)._monaco.promise;
      if (monaco?.editor) {
        monaco.editor.setTheme("vitesse-dark");
        console.log("Theme set: vitesse-dark");
      }
    } catch (themeError) {
      console.warn("Failed to set theme:", themeError);
    }

    isInitialized = true;
    console.log("Monaco workspace initialized with welcome.txt as entry point");

    // If we're on a language page, switch to that language after initialization
    if (language && language !== "welcome") {
      // Small delay to ensure editor is fully ready
      setTimeout(async () => {
        console.log(`Post-initialization switch to ${language}`);
        await switchToLanguageFile(language);
      }, 100);
    } else {
      // Show editor for welcome page
      showEditor();
    }
  } catch (error) {
    console.error("Failed to initialize Monaco editor:", error);
    // Show editor even on error to avoid broken state
    showEditor();
  }
}

// Initialize when DOM is ready
if (document.readyState === "loading") {
  document.addEventListener("DOMContentLoaded", initializeMonacoEditor);
} else {
  initializeMonacoEditor();
}

// Expose the Monaco playground API globally for the formatter component
(window as any).MonacoPlayground = {
  async getCurrentContent(_playgroundElement: HTMLElement): Promise<string> {
    if (!workspace) {
      console.error("Workspace not available");
      return "";
    }

    try {
      const monaco = await (workspace as any)._monaco.promise;
      const editors = monaco.editor.getEditors();
      if (editors.length === 0) return "";

      const editor = editors[0];
      const model = editor.getModel();
      return model ? model.getValue() : "";
    } catch (error) {
      console.error("Failed to get current content:", error);
      return "";
    }
  },

  async updateContent(
    _playgroundElement: HTMLElement,
    newContent: string,
  ): Promise<void> {
    if (!workspace) {
      console.error("Workspace not available");
      return;
    }

    try {
      const monaco = await (workspace as any)._monaco.promise;
      const editors = monaco.editor.getEditors();
      if (editors.length === 0) return;

      const editor = editors[0];
      const model = editor.getModel();
      if (model) {
        model.setValue(newContent);
      }
    } catch (error) {
      console.error("Failed to update content:", error);
    }
  },
};

// Listen for Astro's SPA navigation events
document.addEventListener("astro:before-swap", () => {
  console.log("astro:before-swap detected - preserving Monaco editor state");
  // The editor should remain intact since we're using view transitions
});

// Use multiple event listeners to catch the right timing
document.addEventListener("astro:after-preparation", async () => {
  console.log("astro:after-preparation triggered");
  // This might be a better time to prepare for the switch
});

// Also listen for page visibility changes to re-apply theme if needed
document.addEventListener("visibilitychange", async () => {
  if (!document.hidden && workspace && isInitialized) {
    console.log("Page became visible, ensuring theme is applied");
    try {
      const monaco = await (workspace as any)._monaco.promise;
      if (monaco) {
        monaco.editor.setTheme("vitesse-dark");

        // Refresh all editors
        const editors = monaco.editor.getEditors();
        editors.forEach((editor: any) => {
          editor.layout();
        });
      }
    } catch (error) {
      console.warn("Failed to re-apply theme on visibility change:", error);
    }
  }
});

document.addEventListener("astro:after-swap", async () => {
  console.log("=== astro:after-swap triggered ===");

  // Always derive language from URL to be more reliable
  const path = window.location.pathname;
  const pathMatch = path.match(/\/([^.]+)(?:\.astro)?$/);
  const newLanguage = pathMatch ? pathMatch[1] : null;

  console.log("URL:", path);
  console.log("Derived language:", newLanguage);

  if (!newLanguage || !isInitialized) {
    console.log(
      "Skipping language switch - language:",
      newLanguage,
      "initialized:",
      isInitialized,
    );
    return;
  }

  try {
    console.log("Switching to language:", newLanguage);
    await switchToLanguageFile(newLanguage);
  } catch (error) {
    console.error("Error switching language:", error);
    // Show editor even on error to avoid broken state
    showEditor();
  }
});
</script>
